# Data Model: Todo App Authentication & Security

**Feature**: 003-003-auth-security | **Date**: 2026-01-15
**Purpose**: Define data entities, relationships, and validation rules for JWT-based authentication

## Overview

This feature extends the existing User and Task entities from features 001 and 002 by adding JWT token management and authentication-specific validation. The data model focuses on JWT token structure and user authentication flow rather than database schema changes, as the database schema already exists.

## Entities

### 1. User Entity (Existing - No Schema Changes)

**Purpose**: Represents a registered user account with email and hashed password

**Database Table**: `users` (already exists from feature 001)

**SQLModel Definition** (already exists in `backend/src/models/user.py`):
```python
from sqlmodel import SQLModel, Field
from uuid import UUID, uuid4
from datetime import datetime
from typing import Optional

class User(SQLModel, table=True):
    __tablename__ = "users"

    id: UUID = Field(default_factory=uuid4, primary_key=True)
    email: str = Field(unique=True, index=True, max_length=255)
    hashed_password: str = Field(max_length=255)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

**Validation Rules**:
- **email**: Must be valid email format (RFC 5322), unique across all users, max 255 characters
- **hashed_password**: Must be bcrypt hash with cost factor 10, max 255 characters (bcrypt output is 60 chars)
- **id**: UUID v4, auto-generated, immutable
- **created_at**: Auto-set on creation, immutable
- **updated_at**: Auto-set on creation, updated on modification

**Indexes** (already exist):
- Primary key index on `id`
- Unique index on `email`

**Relationships**:
- One user has many tasks (one-to-many relationship with Task entity)

**Authentication-Specific Notes**:
- Password is never stored in plain text, only bcrypt hash
- Email is used as username for login
- User ID is embedded in JWT token for authentication

---

### 2. Task Entity (Existing - No Schema Changes)

**Purpose**: Represents a todo item owned by a user

**Database Table**: `tasks` (already exists from feature 002)

**SQLModel Definition** (already exists in `backend/src/models/task.py`):
```python
from sqlmodel import SQLModel, Field
from uuid import UUID, uuid4
from datetime import datetime
from typing import Optional

class Task(SQLModel, table=True):
    __tablename__ = "tasks"

    id: UUID = Field(default_factory=uuid4, primary_key=True)
    user_id: UUID = Field(foreign_key="users.id", index=True)
    title: str = Field(max_length=500)
    description: Optional[str] = Field(default=None, max_length=5000)
    is_completed: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

**Validation Rules**:
- **user_id**: Must reference existing user ID, immutable after creation
- **title**: Required, max 500 characters, cannot be empty string
- **description**: Optional, max 5000 characters
- **is_completed**: Boolean, defaults to False
- **id**: UUID v4, auto-generated, immutable
- **created_at**: Auto-set on creation, immutable
- **updated_at**: Auto-set on creation, updated on modification

**Indexes** (already exist):
- Primary key index on `id`
- Index on `user_id` for fast filtering
- Composite index on `(user_id, created_at DESC)` for sorted user task lists

**Foreign Key Constraints**:
- `user_id` references `users.id` with CASCADE delete (if user is deleted, all their tasks are deleted)

**Relationships**:
- Each task belongs to exactly one user (many-to-one relationship with User entity)

**Authentication-Specific Notes**:
- **user_id** is extracted from JWT token and used in all database queries
- All queries MUST include `WHERE user_id = {authenticated_user_id}` to enforce user isolation
- Ownership verification: Before update/delete, verify `user_id` matches authenticated user

---

### 3. JWT Token Entity (Not Stored in Database)

**Purpose**: Represents a signed authentication token containing user identity

**Storage**: Not stored in database (stateless authentication). Token is:
- Generated by Better Auth on frontend after successful login
- Stored in browser (localStorage or httpOnly cookie)
- Sent to backend in Authorization header
- Verified by backend on every protected request

**JWT Token Structure**:
```json
{
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "user@example.com",
  "exp": 1737849600,
  "iat": 1737244800
}
```

**JWT Claims**:
- **user_id** (UUID string): Unique identifier of the authenticated user, used for database queries
- **email** (string): User's email address, for display purposes
- **exp** (integer timestamp): Expiration time (Unix timestamp), set to 7 days from issuance
- **iat** (integer timestamp): Issued at time (Unix timestamp), when token was created

**JWT Header**:
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**Validation Rules**:
- **Signature**: Must be valid HMAC-SHA256 signature using JWT_SECRET
- **Expiration**: Current server time must be less than `exp` claim
- **Algorithm**: Must be HS256 (reject other algorithms to prevent algorithm confusion attacks)
- **user_id**: Must be valid UUID format
- **email**: Must be valid email format

**Token Lifecycle**:
1. **Generation**: Better Auth generates token after successful login (email + password verification)
2. **Issuance**: Token returned to frontend in login response body
3. **Storage**: Frontend stores token in localStorage or httpOnly cookie
4. **Transmission**: Frontend attaches token to API requests in Authorization header: `Bearer <token>`
5. **Verification**: Backend extracts, verifies signature, validates expiration, extracts claims
6. **Expiration**: Token expires after 7 days, user must log in again
7. **Logout**: Frontend deletes token from storage (token remains valid until expiration)

**Security Notes**:
- Token is signed with HS256 algorithm using shared JWT_SECRET
- Token cannot be modified without invalidating signature
- Token expiration is enforced on every request
- Token does not contain sensitive data (no password, only user_id and email)
- Token is transmitted over HTTPS to prevent interception

---

## Pydantic Schemas (Request/Response Validation)

### Authentication Schemas (NEW - to be created in `backend/src/schemas/auth.py`)

```python
from pydantic import BaseModel, EmailStr, Field
from uuid import UUID
from datetime import datetime

class SignupRequest(BaseModel):
    """Request body for user registration"""
    email: EmailStr = Field(..., description="User's email address")
    password: str = Field(..., min_length=8, description="User's password (min 8 characters)")

class SigninRequest(BaseModel):
    """Request body for user login"""
    email: EmailStr = Field(..., description="User's email address")
    password: str = Field(..., description="User's password")

class TokenResponse(BaseModel):
    """Response body containing JWT token"""
    access_token: str = Field(..., description="JWT access token")
    token_type: str = Field(default="bearer", description="Token type (always 'bearer')")
    expires_in: int = Field(default=604800, description="Token expiration in seconds (7 days)")

class UserResponse(BaseModel):
    """Response body containing user information"""
    id: UUID = Field(..., description="User's unique identifier")
    email: str = Field(..., description="User's email address")
    created_at: datetime = Field(..., description="Account creation timestamp")

class ErrorResponse(BaseModel):
    """Structured error response"""
    code: str = Field(..., description="Error code (e.g., 'INVALID_TOKEN', 'TOKEN_EXPIRED')")
    message: str = Field(..., description="Human-readable error message")
    details: dict = Field(default_factory=dict, description="Additional error details")
```

### Task Schemas (Existing - already in `backend/src/schemas/task.py`)

These schemas already exist from feature 002 and do not need changes for authentication. The authentication layer is added via FastAPI dependencies, not schema changes.

---

## Database Queries with User Isolation

### Query Pattern: List User's Tasks

**SQL (with user isolation)**:
```sql
SELECT * FROM tasks
WHERE user_id = '550e8400-e29b-41d4-a716-446655440000'
ORDER BY created_at DESC;
```

**SQLModel (Python)**:
```python
from sqlmodel import select, Session

def get_user_tasks(user_id: UUID, session: Session) -> list[Task]:
    """Get all tasks for authenticated user"""
    statement = select(Task).where(Task.user_id == user_id).order_by(Task.created_at.desc())
    tasks = session.exec(statement).all()
    return tasks
```

**Key Points**:
- `user_id` is extracted from JWT token, not from request parameters
- Query ALWAYS includes `WHERE user_id = {authenticated_user_id}`
- No way for user to access another user's tasks

---

### Query Pattern: Get Single Task with Ownership Verification

**SQL (with user isolation)**:
```sql
SELECT * FROM tasks
WHERE id = 'task-uuid-here'
  AND user_id = '550e8400-e29b-41d4-a716-446655440000';
```

**SQLModel (Python)**:
```python
from sqlmodel import select, Session

def get_task_by_id(task_id: UUID, user_id: UUID, session: Session) -> Optional[Task]:
    """Get task by ID with ownership verification"""
    statement = select(Task).where(
        Task.id == task_id,
        Task.user_id == user_id
    )
    task = session.exec(statement).first()
    return task  # Returns None if task doesn't exist or user doesn't own it
```

**Key Points**:
- Both `task_id` (from URL) and `user_id` (from JWT token) are used in WHERE clause
- Returns None if task doesn't exist OR user doesn't own it
- API returns 404 (not 403) to avoid revealing task existence

---

### Query Pattern: Create Task with User ID

**SQL (with user isolation)**:
```sql
INSERT INTO tasks (id, user_id, title, description, is_completed, created_at, updated_at)
VALUES (uuid_generate_v4(), '550e8400-e29b-41d4-a716-446655440000', 'Task title', NULL, false, NOW(), NOW());
```

**SQLModel (Python)**:
```python
from sqlmodel import Session

def create_task(title: str, description: Optional[str], user_id: UUID, session: Session) -> Task:
    """Create new task for authenticated user"""
    task = Task(
        user_id=user_id,  # Set from JWT token, not from request
        title=title,
        description=description,
        is_completed=False
    )
    session.add(task)
    session.commit()
    session.refresh(task)
    return task
```

**Key Points**:
- `user_id` is set from JWT token, not from request body
- User cannot create tasks for other users
- `user_id` is immutable after creation

---

### Query Pattern: Update Task with Ownership Verification

**SQL (with user isolation)**:
```sql
UPDATE tasks
SET title = 'Updated title',
    description = 'Updated description',
    updated_at = NOW()
WHERE id = 'task-uuid-here'
  AND user_id = '550e8400-e29b-41d4-a716-446655440000';
```

**SQLModel (Python)**:
```python
from sqlmodel import Session

def update_task(task_id: UUID, title: str, description: Optional[str], user_id: UUID, session: Session) -> Optional[Task]:
    """Update task with ownership verification"""
    # First, get task with ownership verification
    task = get_task_by_id(task_id, user_id, session)
    if not task:
        return None  # Task doesn't exist or user doesn't own it

    # Update task fields
    task.title = title
    task.description = description
    task.updated_at = datetime.utcnow()

    session.add(task)
    session.commit()
    session.refresh(task)
    return task
```

**Key Points**:
- Ownership verification happens before update
- Returns None if task doesn't exist or user doesn't own it
- API returns 404 (not 403) for ownership violations

---

### Query Pattern: Delete Task with Ownership Verification

**SQL (with user isolation)**:
```sql
DELETE FROM tasks
WHERE id = 'task-uuid-here'
  AND user_id = '550e8400-e29b-41d4-a716-446655440000';
```

**SQLModel (Python)**:
```python
from sqlmodel import Session

def delete_task(task_id: UUID, user_id: UUID, session: Session) -> bool:
    """Delete task with ownership verification"""
    # First, get task with ownership verification
    task = get_task_by_id(task_id, user_id, session)
    if not task:
        return False  # Task doesn't exist or user doesn't own it

    session.delete(task)
    session.commit()
    return True
```

**Key Points**:
- Ownership verification happens before deletion
- Returns False if task doesn't exist or user doesn't own it
- API returns 404 (not 403) for ownership violations

---

## State Transitions

### User Authentication State

```
[Unauthenticated]
    ↓ (signup with email + password)
[User Created]
    ↓ (signin with email + password)
[JWT Token Issued]
    ↓ (token stored in browser)
[Authenticated]
    ↓ (make API requests with token)
[Authorized]
    ↓ (token expires after 7 days OR user logs out)
[Unauthenticated]
```

**State Descriptions**:
- **Unauthenticated**: No JWT token, cannot access protected endpoints
- **User Created**: User account exists in database with hashed password
- **JWT Token Issued**: Valid JWT token generated and returned to frontend
- **Authenticated**: JWT token stored in browser, attached to API requests
- **Authorized**: JWT token verified by backend, user identity extracted, database queries filtered by user_id
- **Unauthenticated** (after expiration/logout): Token expired or deleted, user must log in again

---

## Migration Scripts

**No database migrations needed** - User and Task tables already exist from features 001 and 002. This feature only adds JWT token logic (not stored in database) and authentication middleware (application layer, not database layer).

**Existing Migrations** (already applied):
- `backend/alembic/versions/001_create_users.py` - Creates users table with indexes
- `backend/alembic/versions/002_create_tasks.py` - Creates tasks table with foreign key and indexes

---

## Summary

This data model extends the existing User and Task entities with JWT-based authentication:

1. **User Entity**: No schema changes, existing table is used for authentication
2. **Task Entity**: No schema changes, existing table is used with user_id filtering
3. **JWT Token Entity**: Not stored in database, stateless authentication token
4. **Pydantic Schemas**: New authentication schemas for signup/signin/token responses
5. **Query Patterns**: All queries include user_id filtering for user isolation
6. **State Transitions**: User authentication lifecycle from signup to token expiration
7. **No Migrations**: No database schema changes needed

The data model enforces user isolation at the database query level by including `WHERE user_id = {authenticated_user_id}` in all queries, ensuring users can only access their own data.
